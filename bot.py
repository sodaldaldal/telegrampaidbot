import os
import json
import time
import asyncio
from telegram import (
    Update, InlineKeyboardMarkup, InlineKeyboardButton,
    LabeledPrice
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, CallbackQueryHandler,
    MessageHandler, filters, PreCheckoutQueryHandler, ContextTypes
)

API_ID = int(os.environ.get("API_ID"))
API_HASH = os.environ.get("API_HASH")
BOT_TOKEN = os.environ.get("BOT_TOKEN")
CHANNEL_ID = int(os.environ.get("CHANNEL_ID"))
PAYMENT_PROVIDER_TOKEN = os.environ.get("PAYMENT_PROVIDER_TOKEN")

DB_FILE = "database.json"

def load_users():
    try:
        with open(DB_FILE, "r") as f:
            return json.load(f)
    except:
        return {}

def save_users(users):
    with open(DB_FILE, "w") as f:
        json.dump(users, f)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üí≥ –ö—É–ø–∏—Ç—å –¥–æ—Å—Ç—É–ø –Ω–∞ 30 –¥–Ω–µ–π", callback_data="buy_access")]
    ])
    await update.message.reply_text(
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª, –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=keyboard
    )

async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    prices = [LabeledPrice("–ü–æ–¥–ø–∏—Å–∫–∞", 199000)]  # 1990.00 UZS

    await context.bot.send_invoice(
        chat_id=query.from_user.id,
        title="–î–æ—Å—Ç—É–ø –≤ –∫–∞–Ω–∞–ª –Ω–∞ 30 –¥–Ω–µ–π",
        description="–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –≤—ã –ø–æ–ª—É—á–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –¥–æ—Å—Ç—É–ø.",
        payload="monthly_access",
        provider_token=PAYMENT_PROVIDER_TOKEN,
        currency="UZS",
        prices=prices,
        start_parameter="access-subscription"
    )

async def precheckout_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.pre_checkout_query.answer(ok=True)

async def successful_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    users = load_users()
    users[str(user_id)] = int(time.time()) + 30 * 24 * 60 * 60
    save_users(users)

    try:
        await context.bot.add_chat_members(CHANNEL_ID, [user_id])
        await update.message.reply_text("‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ –æ–ø–ª–∞—Ç—É! –¢—ã –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞–Ω–∞–ª –Ω–∞ 30 –¥–Ω–µ–π.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏: {e}")

async def check_access(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    users = load_users()
    expire = users.get(str(user_id))

    if expire and expire > int(time.time()):
        remaining = int((expire - time.time()) / 86400)
        await update.message.reply_text(f"‚úÖ –£ —Ç–µ–±—è –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø. –û—Å—Ç–∞–ª–æ—Å—å {remaining} –¥–Ω–µ–π.")
    else:
        await update.message.reply_text("‚õî –£ —Ç–µ–±—è –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∏–ª–∏ –æ–Ω –∏—Å—Ç—ë–∫.")

async def auto_cleanup(bot):
    while True:
        users = load_users()
        now = int(time.time())
        updated = False

        for uid, expire in list(users.items()):
            if expire < now:
                try:
                    await bot.ban_chat_member(CHANNEL_ID, int(uid))
                    await bot.unban_chat_member(CHANNEL_ID, int(uid))
                    print(f"‚õî –£–¥–∞–ª—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –ø–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ –¥–æ—Å—Ç—É–ø–∞.")
                except Exception as e:
                    print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ {uid}: {e}")
                users.pop(uid)
                updated = True

        if updated:
            save_users(users)

        await asyncio.sleep(1800)  # –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç

async def run_cleanup(app):
    await auto_cleanup(app.bot)

def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("check", check_access))
    app.add_handler(CallbackQueryHandler(handle_button))
    app.add_handler(PreCheckoutQueryHandler(precheckout_callback))
    app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment))

    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –≤—Ä—É—á–Ω—É—é
    asyncio.create_task(run_cleanup(app))

    app.run_polling()

if __name__ == "__main__":
    main()
